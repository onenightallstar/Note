# Leetcode-Mid
## 189.轮转数组(2023/11/20)
    给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。


1. gcd求法-环状替代
```java
class Solution {
    public void rotate(int[] nums, int k) {
        for(int i=0;i<gcd(nums.length,k);i++){
            int candidate = nums[i];
            int temp;
            int j = i;
            do{
                temp=nums[(j+k)%nums.length];
                nums[(j+k)%nums.length]=candidate;
                j=(j+k)%nums.length;  
                candidate=temp;       
            }while(j!=i);
        }
        
    }
    private int gcd(int x,int y){
        if(y>x){
            int temp;
            temp=x;
            x=y;
            y=temp;
        }
        if(y==0||x%y==0) return y;
        else return gcd(y,x%y);
    } 
}
```
2. 额外数组
3. 数组翻转： 
  找数组规律-整体分成两部分，并各自排序
  ## 122. 买卖股票的最佳时机Ⅱ(2023/11/20)
      给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
      在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
      返回你能获得的最大利润 。

    1. 贪心：问题可以转化成求多个不重叠的区间最大差，一个区间的多段和可以分解成最小的i和i+1之间的区间差
    2. dp：有两个选择
       1. 手里没有股票的时候继续没有股票 或 买一支股票
       2. 手里有股票的时候继续持有股票 过 卖出股票
## 45. 跳跃游戏 
    给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

    每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

    0 <= j <= nums[i] 
    i + j < n
    返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
---
    解法：
    1. 遍历：把每个的最小跳跃都求出来
    2. 确定每一跳的区间
    3. 贪心：从后往前找最早的跳跃点

## 274.H指数
    给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。

    根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。
---
    解法：
    1. 典型最大中找最小，或者最小中找最大，用二分即可 注意：结束条件，mid算法，l和r怎么确定

## 238.除自身以外数组的乘积
    给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

    题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

    请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
---
    解法：
    1. 多余空间：提前存储i之前的乘积和i之后的乘积
    2. 无多余空间：本质上为从0乘到i-1再从i+1乘到nums.length 可以用从头到尾（0-i-1），从尾到头（nums.length-1-i+1）
## 209.长度最小的子数组
    给定一个含有 n 个正整数的数组和一个正整数 target 。

    找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
---
    解法：
    1. 



